use anyhow::{bail, Result};
use clap::Parser;
use std::io::Write;

use crate::ctf::Context;
use crate::distro;
use crate::{ctf, git};
use elf::abi::{ET_DYN, ET_EXEC};
use serde::Serialize;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use tinytemplate::TinyTemplate;

#[derive(Parser)]
pub struct Exploit {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

#[derive(Parser)]
enum SubCommand {
    /// Generates an exploit skeleton
    #[clap(name = "init")]
    Init(Init),
}

#[derive(Parser)]
pub struct Init {}

#[derive(Serialize)]
struct LinuxUser {
    binary: String,
    host: String,
    port: u16,
}

fn init_linux_user(
    context: &Context,
    challenge_name: &str,
    challenge_dir: &Path,
    binary: String,
    host: String,
    port: u16,
) -> Result<()> {
    let mut templates = TinyTemplate::new();
    let template_name = "pwnit.py";
    templates.add_template(
        template_name,
        std::str::from_utf8(include_bytes!("exploit/linux-user/pwnit.py"))?,
    )?;
    let rendered = templates.render(template_name, &LinuxUser { binary, host, port })?;
    {
        let mut file = std::fs::File::create(challenge_dir.join("pwnit.py"))?;
        let metadata = file.metadata()?;
        let mut permissions = metadata.permissions();
        permissions.set_mode(permissions.mode() | 0o111);
        file.set_permissions(permissions)?;
        file.write_all(rendered.as_bytes())?;
    }
    git::commit(
        context,
        &format!("Add a linux-user exploit skeleton for {}", challenge_name),
    )?;
    Ok(())
}

fn init_linux_kernel(context: &Context, challenge_name: &str, challenge_dir: &Path) -> Result<()> {
    std::fs::write(
        challenge_dir.join("pwnit.c"),
        include_bytes!("exploit/linux-kernel/pwnit.c"),
    )?;
    std::fs::write(
        challenge_dir.join("Makefile"),
        include_bytes!("exploit/linux-kernel/Makefile"),
    )?;
    git::commit(
        context,
        &format!("Add a linux-kernel exploit skeleton for {}", challenge_name),
    )?;
    Ok(())
}

pub fn run(exploit: Exploit, current_dir: PathBuf) -> Result<()> {
    let context = ctf::load(current_dir)?;
    let challenge_name = match context.path.as_slice() {
        [challenge_name, ..] => challenge_name,
        _ => bail!("Not in a challenge directory"),
    };
    let challenge = ctf::find_challenge(&context.ctf, challenge_name)?;
    let challenge_dir = context.root.join(challenge_name);
    match exploit.subcmd {
        SubCommand::Init(_init) => {
            let mut host = "localhost".to_string();
            let mut port = 0;
            if let Some(service) = &challenge.services.first() {
                let parsed = url::Url::parse(&service.url)?;
                if let Some(_host) = parsed.host() {
                    host = _host.to_string();
                }
                if let Some(_port) = parsed.port() {
                    port = _port;
                }
            }
            let mut binary = "/dev/null".into();
            for _binary in &challenge.binaries {
                let binary_path = challenge_dir.join(&_binary.name);
                let info = distro::BinaryInfo::analyze(&binary_path)?;
                if info.kernel_version.is_some() {
                    init_linux_kernel(&context, &challenge.name, &challenge_dir)?;
                    return Ok(());
                }
                if let Some(ehdr) = info.ehdr {
                    if ehdr.e_type == ET_EXEC
                        || (ehdr.e_type == ET_DYN && info.is_pie == Some(true))
                    {
                        binary = Path::new(".")
                            .join(&_binary.name)
                            .into_os_string()
                            .into_string()
                            .unwrap();
                        break;
                    }
                }
            }
            init_linux_user(
                &context,
                &challenge.name,
                &challenge_dir,
                binary,
                host,
                port,
            )?;
        }
    }
    Ok(())
}
